<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2023/02/28/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/02/28/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>GitHub Pages + Hexo组合搭建个人博客环境</p><h2 id="1-Github"><a href="#1-Github" class="headerlink" title="1 Github"></a>1 Github</h2><h3 id="1-1-创建仓库"><a href="#1-1-创建仓库" class="headerlink" title="1.1 创建仓库"></a>1.1 创建仓库</h3><p>创建仓库{用户名}.github.io，将来即可根据域名https:&#x2F;&#x2F;{用户名}.github.io&#x2F;访问博客。</p><h3 id="1-2-设置GitHub-Pages"><a href="#1-2-设置GitHub-Pages" class="headerlink" title="1.2 设置GitHub Pages"></a>1.2 设置GitHub Pages</h3><img src="/2023/02/28/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E8%AE%BE%E7%BD%AEgithubpages.png" class=""><h3 id="1-3-创建Token给Hexo使用"><a href="#1-3-创建Token给Hexo使用" class="headerlink" title="1.3 创建Token给Hexo使用"></a>1.3 创建Token给Hexo使用</h3><img src="/2023/02/28/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%88%9B%E5%BB%BAtoken%E7%BB%99hexo%E4%BD%BF%E7%94%A8.png" class=""><h2 id="2-Hexo"><a href="#2-Hexo" class="headerlink" title="2 Hexo"></a>2 Hexo</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>先安装node，通过node安装Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install node<br>npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="2-2-创建项目"><a href="#2-2-创建项目" class="headerlink" title="2.2 创建项目"></a>2.2 创建项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init hexo-blog<br></code></pre></td></tr></table></figure><h3 id="2-3-初始化启动"><a href="#2-3-初始化启动" class="headerlink" title="2.3 初始化启动"></a>2.3 初始化启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd hexo-blog<br>npm install<br>hexo s<br></code></pre></td></tr></table></figure><h3 id="2-4-安装Fluid主题"><a href="#2-4-安装Fluid主题" class="headerlink" title="2.4 安装Fluid主题"></a>2.4 安装Fluid主题</h3><p><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a>，根据README操作。</p><h4 id="2-4-1-指定主题"><a href="#2-4-1-指定主题" class="headerlink" title="2.4.1 指定主题"></a>2.4.1 指定主题</h4><p>修改hexo-blog项目目录下_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br></code></pre></td></tr></table></figure><h4 id="2-4-2-创建AboutMe"><a href="#2-4-2-创建AboutMe" class="headerlink" title="2.4.2 创建AboutMe"></a>2.4.2 创建AboutMe</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new page about<br></code></pre></td></tr></table></figure><p>修改<code>/source/about/index.md</code>，添加<code>layout</code>属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">more <span class="hljs-built_in">source</span>/about/index.md</span><br>---<br>title: about<br>date: 2023-02-27 22:43:06<br>layout: about<br>---<br></code></pre></td></tr></table></figure><h3 id="2-5-文章同名资源目录"><a href="#2-5-文章同名资源目录" class="headerlink" title="2.5 文章同名资源目录"></a>2.5 文章同名资源目录</h3><p>存放图片文件</p><p>修改hexo-blog项目目录下_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="2-6-个性化页面"><a href="#2-6-个性化页面" class="headerlink" title="2.6 个性化页面"></a>2.6 个性化页面</h3><h4 id="2-6-1-浏览器tab页名称"><a href="#2-6-1-浏览器tab页名称" class="headerlink" title="2.6.1 浏览器tab页名称"></a>2.6.1 浏览器tab页名称</h4><p>修改<code>/hexo-blog/_config.yml</code>中<code>title</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5</span> <span class="hljs-comment"># Site</span><br><span class="hljs-attr">6 title:</span> <span class="hljs-string">光秃秃的猫子</span><br><span class="hljs-attr">7 subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">8 description:</span> <span class="hljs-string">&#x27;Bannirui博客&#x27;</span><br><span class="hljs-attr">9 keywords:</span><br><span class="hljs-attr">10 author:</span> <span class="hljs-string">Banirui</span><br><span class="hljs-attr">11 language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">12 timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="2-6-2-博客主题"><a href="#2-6-2-博客主题" class="headerlink" title="2.6.2 博客主题"></a>2.6.2 博客主题</h4><p>修改<code>/hexo-blog/themes/fluid</code>中<code>blog_title</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">blog_title:</span> <span class="hljs-string">&quot;光秃秃的猫子&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-6-3-主页文字"><a href="#2-6-3-主页文字" class="headerlink" title="2.6.3 主页文字"></a>2.6.3 主页文字</h4><p>修改<code>/hexo-blog/themes/fluid</code>中<code>text</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">text:</span> <span class="hljs-string">&quot;Bannriui的个人博客&quot;</span><br></code></pre></td></tr></table></figure><h3 id="2-7-发布到GitHub"><a href="#2-7-发布到GitHub" class="headerlink" title="2.7 发布到GitHub"></a>2.7 发布到GitHub</h3><h4 id="2-7-1-安装hexo-deployer-git"><a href="#2-7-1-安装hexo-deployer-git" class="headerlink" title="2.7.1 安装hexo-deployer-git"></a>2.7.1 安装hexo-deployer-git</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><h4 id="2-7-2-配置token"><a href="#2-7-2-配置token" class="headerlink" title="2.7.2 配置token"></a>2.7.2 配置token</h4><p>修改<code>/hexo-blog/_config.yml</code>中<code>deploy</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:Bannirui/Bannirui.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br>  <span class="hljs-attr">token:</span> <span class="hljs-string">xxx</span><br></code></pre></td></tr></table></figure><h4 id="2-7-3-创建文章"><a href="#2-7-3-创建文章" class="headerlink" title="2.7.3 创建文章"></a>2.7.3 创建文章</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new post &#123;文章名称&#125;<br></code></pre></td></tr></table></figure><h4 id="2-7-4-发布访问"><a href="#2-7-4-发布访问" class="headerlink" title="2.7.4 发布访问"></a>2.7.4 发布访问</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g -d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大型网站技术架构-核心原理与案例分析</title>
    <link href="/2023/02/28/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <url>/2023/02/28/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="反向代理与CDN加速网站响应"><a href="#反向代理与CDN加速网站响应" class="headerlink" title="反向代理与CDN加速网站响应"></a>反向代理与CDN加速网站响应</h2><ul><li>CND 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据</li><li>反向代理 部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户</li></ul><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p>分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据库部署在不同的物理服务器上</p><h2 id="分布式方案"><a href="#分布式方案" class="headerlink" title="分布式方案"></a>分布式方案</h2><ul><li>分布式应用和服务</li><li>分布式静态资源</li><li>分布式数据和存储</li><li>分布式计算</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ul><li>CDN</li><li>反向代理</li><li>本地缓存</li><li>分布式缓存</li></ul><h2 id="架构要素"><a href="#架构要素" class="headerlink" title="架构要素"></a>架构要素</h2><ul><li>性能</li><li>可用性</li><li>伸缩性</li><li>扩展性<ul><li>事件驱动</li><li>分布式服务</li></ul></li><li>安全性</li></ul><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><ul><li>拒绝服务<ul><li>拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用</li><li>随机拒绝部分请求调用，节约资源，让一部分请求得以成功</li></ul></li><li>关闭功能 关闭部分不重要的服务</li></ul><h2 id="分布式缓存的一致性Hash算法"><a href="#分布式缓存的一致性Hash算法" class="headerlink" title="分布式缓存的一致性Hash算法"></a>分布式缓存的一致性Hash算法</h2><p>一致性Hash算法通过一致性Hash环的数据结构实现Key到缓存服务器的Hash映射</p><h2 id="事件驱动架构"><a href="#事件驱动架构" class="headerlink" title="事件驱动架构"></a>事件驱动架构</h2><p>事件驱动架构(Event Driven Architecture)，通过在低耦合的模块之间传输事件消息，以保持模块的松耦合，并借助事件消息的通信完成模块间的合作</p><h2 id="网络攻击手段"><a href="#网络攻击手段" class="headerlink" title="网络攻击手段"></a>网络攻击手段</h2><ul><li><p>XSS攻击 跨站点校本攻击，黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式</p><ul><li>反射型</li><li>持久型</li></ul></li><li><p>注入攻击</p><ul><li>SQL注入</li><li>OS注入</li></ul></li><li><p>CSRF攻击 攻击者通过跨站请求，以合法用户的身份进行非法操作</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大型分布式网站架构-设计与实现</title>
    <link href="/2023/02/28/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/02/28/%E5%A4%A7%E5%9E%8B%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分库分表"><a href="#1-分库分表" class="headerlink" title="1 分库分表"></a>1 分库分表</h2><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>访问极为频繁且数据量巨大的单表，减少单表的记录条数，以便减少数据查询所需时间，提高数据库的吞吐</p><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>分表能够解决单表数据量过大带来的查询效率下降问题，却无法处理数据库的兵法处理能力，对数据库进行拆分，从而提高数据库的写入能力</p><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><p>temp&#x3D;user_id%(库数量*每个库的表数量)</p><p>库&#x3D;取整(temp&#x2F;每个库的表数量)</p><p>表&#x3D;temp%每个库的表数量</p><h2 id="2-HBase"><a href="#2-HBase" class="headerlink" title="2 HBase"></a>2 HBase</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>HMaster - 负责HRegionServer的调度及集群状态的监管</li><li>HRegionServer - 一个HRegionServer可以管理多个Region</li></ul><p>随着记录条数增加而不断变大后，分裂成一个个的Region，每个Region由(startKey, endKey)表示</p><h2 id="3-垂直化搜索引擎"><a href="#3-垂直化搜索引擎" class="headerlink" title="3 垂直化搜索引擎"></a>3 垂直化搜索引擎</h2><p>分布式系统中，垂直化搜索引擎</p><ul><li>既能满足对全文检索、模糊匹配的续期，解决数据库like查询效率低下的问题</li><li>又能解决分布式环境下由于采用分库分表或者使用NoSQL数据库，导致无法进行多表关联或者复杂查询的问题</li></ul><h3 id="3-1-Lucene"><a href="#3-1-Lucene" class="headerlink" title="3.1 Lucene"></a>3.1 Lucene</h3><h4 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h4><p>又称反向索引，是搜索引擎中最常见的数据结构，将文档中的词作为关键字，建立词与文档的映射关系，通过对倒排索引的检索，可以根据词快速获取包含这个词的文档列表</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul><li>索引读写分离</li><li>索引切分</li></ul><h2 id="4-弱一致性"><a href="#4-弱一致性" class="headerlink" title="4 弱一致性"></a>4 弱一致性</h2><h3 id="不一致性窗口"><a href="#不一致性窗口" class="headerlink" title="不一致性窗口"></a>不一致性窗口</h3><p>弱一致性指的是系统的某个数据被更新后，后续对该数据的读取操作获取到的可能是更新前的值，也可能是更新后的值，全部用户完全获取到更新后的值需要经过一段时间</p><h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>是弱一致性的一种特殊形式</p><h4 id="最终一致性案例"><a href="#最终一致性案例" class="headerlink" title="最终一致性案例"></a>最终一致性案例</h4><ul><li>MySQL数据库的主&#x2F;从数据同步</li><li>ZooKeeper的Leader election和Atomic broadcas</li></ul><h2 id="5-并发扣减库存"><a href="#5-并发扣减库存" class="headerlink" title="5 并发扣减库存"></a>5 并发扣减库存</h2><ul><li><p>杜绝网络投机者使用工具参与秒杀导致的不公平竞争行为，让竞争变得公平</p><ul><li>图像验证码</li><li>问答式验证码</li></ul></li><li><p>高并发</p><ul><li>分库分表</li></ul></li><li><p>数据一致性问题</p><ul><li><p>实际库存与浏览库存分离</p><p>真实的库存保存在数据库中，前端浏览的库存信息存放在缓存中，数据库下单与减库存两个动作可以在同一个事务中执行，避免数据不一致</p><p>库存更新完毕后，再将数据库中的数据同步到缓存中</p></li></ul></li><li><p>行锁竞争</p><p>将一行库存拆分成多行，解除行锁导致的并发资源利用问题，下单减库存操作路由到哪条记录</p><ul><li>用户id取模</li><li>随机</li></ul></li><li><p>总库存大于0，前端下单请求可能刚好被路由到一条库存为0的记录，导致扣减库存失败，而实际上还有其他记录库存不是0</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式数据库系统</title>
    <link href="/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/02/28/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>分布式数据库系统与集中式数据库系统一样，包含两个部分</p><ul><li>数据库</li><li>数据库管理系统 管理和操作数据库的软件，介于应用程序和操作系统之间</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>分布式数据库系统是地理上分散而逻辑上集中的数据库系统</p><h3 id="节点-x2F-场地"><a href="#节点-x2F-场地" class="headerlink" title="节点&#x2F;场地"></a>节点&#x2F;场地</h3><p>分布式系统通常由计算机网络将地理上分散的各逻辑单位连接起来而组成的，被连接的逻辑单位称为节点或场地</p><ul><li>节点 强调的是计算机和处理能力</li><li>场地 强调的是地理位置和通信代价</li></ul><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>分布在一个计算机网络上的多个逻辑相关的数据库的集合</p><h3 id="分布式数据库管理系统"><a href="#分布式数据库管理系统" class="headerlink" title="分布式数据库管理系统"></a>分布式数据库管理系统</h3><p>分布式数据库管理系统是分布式数据库系统的一组软件，负责对分布式数据库中的数据进行管理和操作</p><ul><li>全局的查询处理器</li><li>事务管理器</li><li>并发控制器</li><li>恢复管理器</li></ul><p>保证全局事务执行的高效性、正确性和可靠性</p><p>系统接收基于全局模式的全局查询命令，根据数据的分布式信息将一个全局查询命令转换为面向各个局部场地的子查询请求，同时将一个全局事务分解为相应的子事务分布式处理</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>数据透明性<ul><li>分布透明性</li><li>分片透明性</li><li>复制透明性</li></ul></li><li>场地自治性<ul><li>设计自治性</li><li>通信自治性</li><li>执行自治性</li></ul></li></ul><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><p>HBase集群中，主要有四大功能组件</p><h3 id="HMasterServer"><a href="#HMasterServer" class="headerlink" title="HMasterServer"></a>HMasterServer</h3><p>主服务器</p><p>HMasterServer是HBase整个集群的管理者，主要负责管理数据表Table和区域Region以及响应用户的数据请求，保证用户对数据的访问</p><ul><li><p>保存和管理关于存取数据信息的元数据信息</p></li><li><p>管理用户对表的增加、删除、修改和查询</p></li><li><p>调整HRegion的分布，管理HRegionServer的数据和负载均衡</p></li><li><p>负责新HRegion的分配</p></li><li><p>在HRegionServer停机后，负责时效HRegionServer上的HRegion迁移</p></li><li><p>处理对HBase schema的变更请求</p></li></ul><h3 id="HRegionServer"><a href="#HRegionServer" class="headerlink" title="HRegionServer"></a>HRegionServer</h3><p>数据服务器</p><p>HRegionServer是每个Region的管理者和用户服务的提供者，它管理本地数据，并响应用户的数据读取请求</p><p>一般情况下，在HBase集群中，每台机器上只运行一个HRegionServer</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>HBase集群的分布式协调器</p><ul><li>保证在任何时刻，集群中只有一个master</li><li>存储所有Region的入口地址，HMasterServer启动时会将HBase系统表Root加载到Zookeeper上，并通过Zookeeper cluster获取当前系统表Meta的存储所对应的RegionServer信息</li><li>实时监控HRegionServer状态，将HRegionServer的上线和下线信息实时通知给HMasterServer。HRegionServer会以短暂的方式向Zookeeper注册，使得HMasterServer可以随时赶至各个HRegionServer是否在线的状态信息</li><li>存储HBase的schema是否在线的状态信息，包括有哪些表，每个表有哪些列簇</li></ul><h3 id="Client-Library"><a href="#Client-Library" class="headerlink" title="Client Library"></a>Client Library</h3><p>客户端类库</p><p>封装用于支持HBase数据操作和客户端开发的API集合</p><h2 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h2><h3 id="传播方式"><a href="#传播方式" class="headerlink" title="传播方式"></a>传播方式</h3><ul><li>同步复制</li><li>异步复制</li></ul><h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><ul><li>主从复制</li><li>对等复制</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>基于触发器法</li><li>基于日志法</li><li>基于时间戳法</li><li>基于API法</li></ul><h2 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h2><p>将对数据的增量更新暂存在内存中，达到指定的存储阈值后将更新批量写入磁盘，在批量写入的过程中与已经存在的数据做合并操作</p><p>在数据读取时，同样需要合并磁盘中的数据和内存中最近修改操作</p><h4 id="读写控制方式"><a href="#读写控制方式" class="headerlink" title="读写控制方式"></a>读写控制方式</h4><ul><li>写 防止大量数据更新造成的磁盘随机写入</li><li>读 需要多次磁盘I&#x2F;O访问较多的文件</li></ul><h2 id="键值模型"><a href="#键值模型" class="headerlink" title="键值模型"></a>键值模型</h2><ul><li>键值型<ul><li>基于键排序</li><li>基于一致性散列</li></ul></li><li>列族型</li><li>超级列族型</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Paxos到Zookeeper-分布式一致性原理与实践</title>
    <link href="/2023/02/28/%E4%BB%8EPaxos%E5%88%B0Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/02/28/%E4%BB%8EPaxos%E5%88%B0Zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-分布式特点"><a href="#1-分布式特点" class="headerlink" title="1 分布式特点"></a>1 分布式特点</h2><ul><li>分布性</li><li>对等性</li><li>并发性</li><li>缺乏全局时钟</li><li>故障总会发生</li></ul><h2 id="2-分布式问题"><a href="#2-分布式问题" class="headerlink" title="2 分布式问题"></a>2 分布式问题</h2><ul><li>通信异常</li><li>网络分区</li><li>三态 单体应用中一次请求的结果总是明确的，分布式系统中因为网络是不可靠的，导致成功、失败和超时</li><li>节点故障</li></ul><h2 id="3-单机事务"><a href="#3-单机事务" class="headerlink" title="3 单机事务"></a>3 单机事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>A&#x3D;Atomicity 原子性</p><p>C&#x3D;Consistency 一致性</p><p>I&#x3D;Isolation 隔离性</p><p>D&#x3D;Durability 持久性</p><h2 id="4-分布式理论"><a href="#4-分布式理论" class="headerlink" title="4 分布式理论"></a>4 分布式理论</h2><h3 id="4-1-CAP"><a href="#4-1-CAP" class="headerlink" title="4.1 CAP"></a>4.1 CAP</h3><p>C&#x3D;Consistency 一致性</p><p>A&#x3D;可用性</p><p>P&#x3D;分区容错性</p><p>分区容错性约束了一个分布式系统在遇到任何网络分区故障的时候，都要能够保证对外提供满足一致性和可用性的服务，除非是整个网络都发生故障</p><h3 id="4-2-BASE"><a href="#4-2-BASE" class="headerlink" title="4.2 BASE"></a>4.2 BASE</h3><p>BA&#x3D;Basically Available 基本可用</p><p>S&#x3D;Soft State 软状态</p><p>E&#x3D;Eventually consistent 最终一致性</p><h3 id="4-3-最终一致性变种"><a href="#4-3-最终一致性变种" class="headerlink" title="4.3 最终一致性变种"></a>4.3 最终一致性变种</h3><p>因果一致性</p><p>读己之所写</p><p>会话一致性</p><p>单调读一致性</p><p>单调写一致性</p><h2 id="5-一致性协议"><a href="#5-一致性协议" class="headerlink" title="5 一致性协议"></a>5 一致性协议</h2><h3 id="5-1-2PC"><a href="#5-1-2PC" class="headerlink" title="5.1 2PC"></a>5.1 2PC</h3><h4 id="5-1-1-角色"><a href="#5-1-1-角色" class="headerlink" title="5.1.1 角色"></a>5.1.1 角色</h4><p>协调者 统一调度所有分布式节点的执行逻辑</p><p>参与者 执行节点</p><h4 id="5-1-2-阶段"><a href="#5-1-2-阶段" class="headerlink" title="5.1.2 阶段"></a>5.1.2 阶段</h4><h5 id="阶段一-提交事务请求"><a href="#阶段一-提交事务请求" class="headerlink" title="阶段一 提交事务请求"></a>阶段一 提交事务请求</h5><ol><li>事务询问 协调者向参与者询问是否可以执行事务</li><li>执行事务 参与者执行事务，记录Undo和Redo日志信息</li><li>反馈响应 参与者反馈Ack，可以执行事务返回Yes，不可以执行事务返回No</li></ol><h5 id="阶段二-执行事务提交"><a href="#阶段二-执行事务提交" class="headerlink" title="阶段二 执行事务提交"></a>阶段二 执行事务提交</h5><p>协调者根据Ack决策</p><ol><li>提交事务 所有参与者都回复Yes表示可以执行事务<ol><li>协调者告诉参与者进行Commit</li><li>参与者提交事务，释放独占的资源</li><li>参与者向协调者Ack</li><li>协调者收到所有Ack 整个分布式事务结束</li></ol></li><li>回滚事务 但凡有一个参与者回复No<ol><li>协调者向参与者发送Rollback请求</li><li>参与者执行回滚，释放独占的资源</li><li>参与者回复协调者Ack</li><li>协调者收到所有参与者Ack后 整个分布式事务宣告结束</li></ol></li></ol><h4 id="5-1-3-两阶段协议问题"><a href="#5-1-3-两阶段协议问题" class="headerlink" title="5.1.3 两阶段协议问题"></a>5.1.3 两阶段协议问题</h4><ul><li>同步阻塞</li><li>单点问题 极度依赖协调者</li><li>数据不一致 第二阶段时，协调者向参与者发送提交请求时，发送一半出现网络问题，导致有的参与者提交了事务，有的参与者没有提交事务</li><li>过于保守 没有设计完善的容错机制，任意一个节点的失败都会导致整个事务的失败</li></ul><h3 id="5-2-3PC"><a href="#5-2-3PC" class="headerlink" title="5.2 3PC"></a>5.2 3PC</h3><h4 id="5-2-1-角色"><a href="#5-2-1-角色" class="headerlink" title="5.2.1 角色"></a>5.2.1 角色</h4><p>协调者 统一调度所有分布式节点的执行逻辑</p><p>参与者 执行节点</p><h4 id="5-2-2-阶段"><a href="#5-2-2-阶段" class="headerlink" title="5.2.2 阶段"></a>5.2.2 阶段</h4><h5 id="阶段一-CanCommit"><a href="#阶段一-CanCommit" class="headerlink" title="阶段一 CanCommit"></a>阶段一 CanCommit</h5><h5 id="阶段二-PreCommit"><a href="#阶段二-PreCommit" class="headerlink" title="阶段二 PreCommit"></a>阶段二 PreCommit</h5><h5 id="阶段三-doCommit"><a href="#阶段三-doCommit" class="headerlink" title="阶段三 doCommit"></a>阶段三 doCommit</h5><h4 id="5-2-3-三阶段提交的问题"><a href="#5-2-3-三阶段提交的问题" class="headerlink" title="5.2.3 三阶段提交的问题"></a>5.2.3 三阶段提交的问题</h4><p>参与者接收到preCommit消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行网络通信，在这种情况下，该参与者依然会进行事物的提交，导致数据不一致</p><h2 id="6-Paxios算法"><a href="#6-Paxios算法" class="headerlink" title="6 Paxios算法"></a>6 Paxios算法</h2><p>基于消息传递且具有高度容错特性的一致性算法</p><p>引入<code>过半</code>理念和支持分布式节点角色转换，避免了分布式单点问题，也解决了无限期待问题</p><h3 id="6-1-一致性安全需求"><a href="#6-1-一致性安全需求" class="headerlink" title="6.1 一致性安全需求"></a>6.1 一致性安全需求</h3><ul><li>只有被剔除的提案才能被选定</li><li>只有一个值被选定</li><li>如果某个进程认为某个提案被选定了，那么这个提案必须是真的被选定的那个</li></ul><h3 id="6-2-目标"><a href="#6-2-目标" class="headerlink" title="6.2 目标"></a>6.2 目标</h3><p>保证最终有一个提案会被选定，当提案被选定之后，进程最终也能获取到被选定的提案</p><h3 id="6-3-角色"><a href="#6-3-角色" class="headerlink" title="6.3 角色"></a>6.3 角色</h3><ul><li>Proposer</li><li>Acceptor</li><li>Learner</li></ul><h3 id="6-4-过程"><a href="#6-4-过程" class="headerlink" title="6.4 过程"></a>6.4 过程</h3><h4 id="6-4-1-提案的选定"><a href="#6-4-1-提案的选定" class="headerlink" title="6.4.1 提案的选定"></a>6.4.1 提案的选定</h4><p>Poposer向一个Acceptor集合发送提案</p><p>足够多的Acceptor是整个Acceptor集合的一个子集，并且让这个集合大的可以包含Acceptor集合中的大多数成员</p><p>提案由一个编号和Value的组成的组合体，[编号, Value]</p><h4 id="6-4-2-Proposer生成提案"><a href="#6-4-2-Proposer生成提案" class="headerlink" title="6.4.2 Proposer生成提案"></a>6.4.2 Proposer生成提案</h4><p>Proposer在产生一个编号为M<sub>n</sub>的提案时，必须要知道某一个将要活着已经被半数以上Acceptor批准的编号小于M<sub>n</sub>但为最大编号的提案，并且Proposer会要求所有的Acceptor都不要再批准任何编号小于M<sub>n</sub>的提案</p><h4 id="6-4-3-Acceptor批准提案"><a href="#6-4-3-Acceptor批准提案" class="headerlink" title="6.4.3 Acceptor批准提案"></a>6.4.3 Acceptor批准提案</h4><p>一个Acceptor可能会收到来自Proposer的两种请求，分别是Prepare请求和Accept请求</p><ul><li>Prepare请求 Acceptor可以在任何时候响应一个Prepare请求</li><li>Accept请求 在不违背Accept现有承诺的前提下，可以任意响应Accept请求</li></ul><h3 id="6-5-算法"><a href="#6-5-算法" class="headerlink" title="6.5 算法"></a>6.5 算法</h3><h4 id="6-5-1-Proposer和Acceptor提案选定"><a href="#6-5-1-Proposer和Acceptor提案选定" class="headerlink" title="6.5.1 Proposer和Acceptor提案选定"></a>6.5.1 Proposer和Acceptor提案选定</h4><h5 id="阶段一"><a href="#阶段一" class="headerlink" title="阶段一"></a>阶段一</h5><p>1 Proposer选择一个提案编号M<sub>n</sub>，然后向Acceptor的某个超过半数的子集发送编号为M<sub>n</sub>的Prepare请求</p><p>2 如果一个Acceptor收到一个编号为M<sub>n</sub>的Prepare请求，且编号M<sub>n</sub>大于该Acceptor已经响应过的所有Prepare请求的编号，那么它就会将已经批准过的最大编号作为响应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于M<sub>n</sub>的提案</p><h5 id="阶段二"><a href="#阶段二" class="headerlink" title="阶段二"></a>阶段二</h5><p>1 如果Proposer收到来自半数以上的Acceptor对于其发出的编号为M<sub>n</sub>的Prepare请求的响应，那么它就会发送一个针对[M<sub>n</sub>,V<sub>n</sub>]提案的Accept请求给Acceptor</p><p>2 如果Acceptor收到针对这个[M<sub>n</sub>,V<sub>n</sub>]提案的Accept请求，只要该Acceptor尚未对编号大于M<sub>n</sub>的Prepare请求作出响应，就会通过这个提案</p><h4 id="6-5-2-Learner获取提案"><a href="#6-5-2-Learner获取提案" class="headerlink" title="6.5.2 Learner获取提案"></a>6.5.2 Learner获取提案</h4><h4 id="6-5-3-选取主Proposer保证算法活性"><a href="#6-5-3-选取主Proposer保证算法活性" class="headerlink" title="6.5.3 选取主Proposer保证算法活性"></a>6.5.3 选取主Proposer保证算法活性</h4><h2 id="7-zk"><a href="#7-zk" class="headerlink" title="7 zk"></a>7 zk</h2><h3 id="7-1-集群角色"><a href="#7-1-集群角色" class="headerlink" title="7.1 集群角色"></a>7.1 集群角色</h3><ul><li>Leader</li><li>Follower</li><li>Observer</li></ul><h3 id="7-2-数据结构"><a href="#7-2-数据结构" class="headerlink" title="7.2 数据结构"></a>7.2 数据结构</h3><p>ZNode</p><ul><li>持久节点 除非主动移除，否则一直保存在zk上</li><li>临时节点 生命周期跟客户端会话绑定</li></ul><p>SEQUENTIAL属性 zk允许用户为每个节点添加属性，一旦节点被标记上这个属性，那么在这个节点被创建的时候，zk会自动在其节点后面追加上一个整型数字(由父节点维护的自增数字)</p><h3 id="7-3-版本"><a href="#7-3-版本" class="headerlink" title="7.3 版本"></a>7.3 版本</h3><p>对于每个ZNode，zk都会维护一个Stat的数据结构</p><p>Stat中记录了这个ZNode的3个数据版本</p><ul><li>version 当前ZNode的版本</li><li>cversion 当前ZNode子节点的版本</li><li>aversion 当前ZNode的ACL版本</li></ul><h3 id="7-4-ZAB协议"><a href="#7-4-ZAB协议" class="headerlink" title="7.4 ZAB协议"></a>7.4 ZAB协议</h3><p>ZooKeeper Atomic Broadcast zk原子广播协议，数据一致性的核心算法</p><p>支持崩溃恢复的原子广播协议</p><p>zk使用一个单一的主进程接收并处理客户端的所有事务请求，采用ZAB的原子广播协议，将服务器数据的变更以事务Proposal的形式广播到所有的副本进程上</p><p>ZAB协议的这个主备模型架构保证了同一时刻集群中只能有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端大量的并发请求</p><p>ZAB协议的核心是定义了对于那些会改变zk服务器数据状态的事务请求的处理方式</p><ul><li>所有事务请求必须由一个全局唯一的服务器来协调处理，即Leader</li><li>Leader服务器负责将一个客户端事务请求转为一个事务Proposal提议，并将该Proposal分发给集群中所有的follower服务器</li><li>Leader服务器等待所有Follower服务器的反馈，收到半数后Leader就会再次向所有Follower服务器分发Commit消息，要求将Proposal进行提交</li></ul><p>ZAB协议包括两种基本模式</p><ul><li>崩溃恢复<ul><li>整个服务框架启动或者Lader出现网络中断、崩溃退出与重启等异常情况时，ZAB协议就会进入恢复模式并选举产生新的Leader</li><li>当选举产生了新的Leader，同步集群中过半机器与Leader完成了同步之后ZAB就会退出恢复模式</li></ul></li><li>消息广播<ul><li>集群中已经过半的Follower完成了和Leader的状态同步，那么整个服务框架就可以进入消息广播模式了</li><li>当一台同样遵守ZAB协议的服务器启动后加入到集群时，如果此时集群中已经存在了一个Leader在负责进行消息广播，那么新加入的服务器会自觉加入数据恢复模式<ul><li>找到Leader所在的服务器，并与其进行数据同步</li><li>然后一起参与到消息广播流程中</li></ul></li></ul></li></ul><p>ZAB协议的事务编号ZXID设计中，64位</p><ul><li>高32位 代表了Leader周期epoch的编号，每当选举产生一个新的Leader服务器，就会从这个服务器上本地日志中最大事务Proposal的ZXID中解析出对应的epoch值加1</li><li>低32位 单调递增的计数器，针对客户端的每一个事务请求，Leader服务器在产生一个的新的事务Proposal的时候都会对该计数器进行加1操作</li></ul><h4 id="7-4-1-过程"><a href="#7-4-1-过程" class="headerlink" title="7.4.1 过程"></a>7.4.1 过程</h4><ul><li>崩溃恢复</li><li>消息广播</li></ul><h4 id="7-4-2-阶段"><a href="#7-4-2-阶段" class="headerlink" title="7.4.2 阶段"></a>7.4.2 阶段</h4><ul><li>发现 Leader选举过程</li><li>同步</li><li>广播 ZAB协议正式开始接收客户端新的事务请求，并进行消息广播流程</li></ul><h4 id="7-4-3-状态"><a href="#7-4-3-状态" class="headerlink" title="7.4.3 状态"></a>7.4.3 状态</h4><ul><li>Looking Leader选举阶段</li><li>Following Follower服务器和Leader服务器保持同步状态</li><li>Leading Leader服务器作为主进程领导状态</li></ul><h2 id="8-ZAB-vs-Paxos"><a href="#8-ZAB-vs-Paxos" class="headerlink" title="8 ZAB vs Paxos"></a>8 ZAB vs Paxos</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>设计目标不一样</p><ul><li>ZAB协议主要用于构建一个高可用的分布式数据主备系统</li><li>Paxos算法用于构建一个分布式的一致性状态机系统</li></ul><h3 id="5-6-zk典型应用场景"><a href="#5-6-zk典型应用场景" class="headerlink" title="5.6 zk典型应用场景"></a>5.6 zk典型应用场景</h3><ul><li>数据发布&#x2F;订阅</li><li>负载均衡</li><li>命名服务</li><li>分布式协调&#x2F;通知</li><li>集群管理</li><li>Master选举</li><li>分布式锁</li><li>分布式队列</li></ul>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
